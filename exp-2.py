# Experiment 2:
    #Complexity Drill (Operation Counting)
# Aim:
    #Develop intuition for time/space complexity using simple loop structures and case analysis.
# What you will implement (in lab):
    #Create 4 snippets: single loop, nested loop, triangular loop, and halving loop. Count operations roughly and map to Big-O. Add best/avg/worst reasoning for linear search and
    #binary search.
# Input / Output expectation:
    #Input: n. Output: for each snippet print estimated operation count + complexity label+ 2-line justification.
# Lab checkpoints (faculty verifies):
    #• Correct mapping for O(1), O(n), O(n2), O(logn)
    #• Clear best/avg/worst definitions with examples
# Viva:
    #1. Big-O vs Big-Theta difference?
    #2. What does worst-case represent?
    #3. Why complexity matters in real systems?

# SOLUION :

# Loop Analysis

# Single Loop
    # Operations proportional to n
    # Time complexity = O(n)

# Nested Loop
    # Operations = n × n
    # Time complexity = O(n²)

# Triangular Loop

    # Operations = n(n+1)/2
    # Time complexity = O(n²)

# Halving Loop

    # Input reduces by half each step
    # Time complexity = O(log n)
    
# Linear Search Complexity

    # Best case → O(1)
    # Average case → O(n)
    # Worst case → O(n)

# Binary Search Complexity

    # Best case → O(1)
    # Average case → O(log n)
    # Worst case → O(log n)
